# Copyright (c) 2014 The Chromium Embedded Framework Authors. All rights
# reserved. Use of this source code is governed by a BSD-style license that
# can be found in the LICENSE file.

import argparse
import sys
from pathlib import Path

from date_util import get_year
from file_util import path_exists, read_file, write_file
import git_util as git
from readme_util import read_readme_file

SCRIPT_DIR = Path(__file__).resolve().parent
JCEF_DIR = SCRIPT_DIR.parent

LICENSE_HEADER = """\
// Copyright (c) {year} The Chromium Embedded Framework Authors. All rights
// reserved. Use of this source code is governed by a BSD-style license that
// can be found in the LICENSE file.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//    * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//    * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//    * Neither the name of Google Inc. nor the name Chromium Embedded
// Framework nor the names of its contributors may be used to endorse
// or promote products derived from this software without specific prior
// written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// ---------------------------------------------------------------------------
//
// This file is generated by the make_version_header.py tool.
//

#ifndef JCEF_INCLUDE_JCEF_VERSION_H_
#define JCEF_INCLUDE_JCEF_VERSION_H_

#define JCEF_VERSION "{version}"
#define JCEF_COMMIT_NUMBER {commit_number}
#define JCEF_COMMIT_HASH "{commit_hash}"
#define JCEF_COPYRIGHT_YEAR {year}

#define DO_MAKE_STRING(p) #p
#define MAKE_STRING(p) DO_MAKE_STRING(p)

#endif  // JCEF_INCLUDE_JCEF_VERSION_H_
"""


def build_header_contents(version: str, commit_number: str, commit_hash: str,
                          year: str) -> str:
  return LICENSE_HEADER.format(
      version=version,
      commit_number=commit_number,
      commit_hash=commit_hash,
      year=year)


def write_svn_header(header_path: Path, cef_path: Path) -> bool:
  """Create or update the header file for the current revision."""
  oldcontents = read_file(header_path) if path_exists(header_path) else ''

  if not git.is_checkout(JCEF_DIR):
    raise Exception('Not a valid checkout')

  commit_number = git.get_commit_number(JCEF_DIR)
  commit_hash = git.get_hash(JCEF_DIR)
  year = get_year()

  version_args = {}
  read_readme_file(cef_path / 'README.txt', version_args)

  version = '%s.%s.%s.%s+g%s' % (version_args['CEF_MAJOR'],
                                 version_args['CEF_MINOR'],
                                 version_args['CEF_PATCH'], commit_number,
                                 commit_hash[:7])

  newcontents = build_header_contents(version, commit_number, commit_hash, year)
  if newcontents != oldcontents:
    write_file(header_path, newcontents)
    return True

  return False


def parse_args(argv):
  parser = argparse.ArgumentParser(
      description="Create the JCEF version header file.")
  parser.add_argument(
      '--header',
      dest='header',
      required=True,
      metavar='FILE',
      help='output version header file')
  parser.add_argument(
      '--cef-path',
      dest='cefpath',
      required=True,
      help='path to the CEF binary distribution')
  parser.add_argument(
      '-q',
      '--quiet',
      action='store_true',
      dest='quiet',
      default=False,
      help='do not output detailed status information')
  return parser.parse_args(argv)


def main(argv=None):
  args = parse_args(argv or sys.argv[1:])
  header_path = Path(args.header)
  cef_path = Path(args.cefpath)

  updated = write_svn_header(header_path, cef_path)
  if not args.quiet:
    if updated:
      sys.stdout.write(f'File {header_path} updated.\n')
    else:
      sys.stdout.write(f'File {header_path} is already up to date.\n')


if __name__ == "__main__":
  main()
